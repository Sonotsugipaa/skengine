constexpr const char* cullCompShader = "#version 460\n" // https://vkguide.dev/docs/gpudriven/compute_culling/
"\n"
"layout(constant_id = 0) const uint LOCAL_SIZE_X = 16;\n"
"layout(constant_id = 1) const uint LOCAL_SIZE_Y = 1;\n"
"layout(constant_id = 2) const uint LOCAL_SIZE_Z = 1;\n"
"\n"
"layout(\n"
	"local_size_x_id = 0,\n"
	"local_size_y_id = 1,\n"
	"local_size_z_id = 2\n"
") in;\n"
"\n"
"layout(push_constant) uniform constants {\n"
	"uint objCount;\n"
"} pc;\n"
"\n"
"struct Object {\n"
	"mat4  model_transf;\n"
	"vec4  color_mul;\n"
	"vec4  cull_sphere_xyzr;\n"
	"float rnd;\n"
	"uint  draw_batch_idx;\n"
	"bool  visible;\n"
	"uint  unused1;\n"
"};\n"
"\n"
"struct DrawBatch {\n"
	"uint indexCount;\n"
	"uint instanceCount;\n"
	"uint firstIndex;\n"
	"int  vertexOffset;\n"
	"uint firstInstance;\n"
"};\n"
"\n"
"layout(std430, set = 0, binding = 0) /*readonly*/ buffer ObjectBuffer {\n"
	"Object p[];\n"
"} obj_buffer;\n"
"layout(std430, set = 0, binding = 1) writeonly buffer ObjectIdBuffer {\n"
	"uint p[];\n"
"} obj_id_buffer;\n"
"layout(std430, set = 0, binding = 2) buffer DrawBatchBuffer {\n"
	"DrawBatch p[];\n"
"} draw_batch_buffer;\n"
"\n"
"layout(std140, set = 0, binding = 3) uniform CullPassUbo {\n"
	"mat4 view_transf;\n"
	"vec4 frustum_lrtb;\n"
	"vec4 z_near_far;\n"
	"bool frustum_culling_enabled;\n"
"} cull_pass_ubo;\n"
"\n"
"bool isVisible(uint idx) {\n"
	"\n" // Credit for the math: https://github.com/zeux/niagara/blob/master/src/shaders/drawcull.comp.glsl
	"bool frustum_culling_enabled = cull_pass_ubo.frustum_culling_enabled\n;"
	"float z_near = cull_pass_ubo.z_near_far[0]\n;"
	"float z_far  = cull_pass_ubo.z_near_far[1]\n;"
	"if(! frustum_culling_enabled) return true\n;"
	"vec4 sph = obj_buffer.p[idx].cull_sphere_xyzr;\n"
	"sph.xyz = (cull_pass_ubo.view_transf * vec4(sph.xyz, 1.0)).xyz;\n"
	"bool r = obj_buffer.p[idx].visible\n"
		"&& (((sph.z * cull_pass_ubo.frustum_lrtb[1]) - (abs(sph.x) * cull_pass_ubo.frustum_lrtb[0])) > -sph.w)\n"
		"&& (((sph.z * cull_pass_ubo.frustum_lrtb[3]) - (abs(sph.y) * cull_pass_ubo.frustum_lrtb[2])) > -sph.w)\n"
		"&& ((-sph.z + sph.w) > z_near)\n"
		"&& ((-sph.z - sph.w) < z_far);\n"
	"return r;\n"
"}\n"
"\n"
"void main() {\n"
	"uint invocId = gl_GlobalInvocationID.x;\n"
	"if(invocId < pc.objCount) {\n"
		"uint objIdx = invocId;\n"
		"bool visible = isVisible(objIdx);\n"
		"if(visible) {\n"
			"uint batchIdx = obj_buffer.p[invocId].draw_batch_idx;\n"
			"uint insertAt = atomicAdd(draw_batch_buffer.p[batchIdx].instanceCount, 1);\n"
			"uint instIdx = draw_batch_buffer.p[batchIdx].firstInstance + insertAt;\n"
			"obj_id_buffer.p[instIdx] = objIdx;\n"
		"}\n"
	"}\n"
"}\n";