#pragma once

#include <cstdint>

#include <skengine_fwd.hpp>

#include <vma/vk_mem_alloc.h>

#include <sflog.hpp>



#define ALIGNF32(N_) alignas((N_) * sizeof(float))
#define ALIGNI32(N_) alignas((N_) * sizeof(uint32_t))
#define ALIGNFLAGS(N_) alignas((N_) * sizeof(uint32_t))



namespace SKENGINE_NAME_NS {

	// The signedness of an underlying type matters:
	// signed types allow special, predefined, valid (negative) values that
	// are not automatically generated by the `idgen` library.
	#define DECL_SCOPED_ENUM_(ENUM_, ALIAS_, UNDERLYING_) using ALIAS_ = UNDERLYING_; enum class ENUM_ : ALIAS_ { };
	DECL_SCOPED_ENUM_(RendererId,      renderer_id_e,       unsigned)
	DECL_SCOPED_ENUM_(RenderTargetId,  render_target_id_e,  unsigned)
	DECL_SCOPED_ENUM_(RenderPassId,    render_pass_id_e,    unsigned)
	#undef DECL_SCOPED_ENUM_


	using Logger = sflog::Logger<std::shared_ptr<posixfio::OutputBuffer>>;

	template <typename Logger, typename... Pfx>
	Logger cloneLogger(const Logger& cp, Pfx&&... pfx) { return Logger(cp.sink(), cp.getLevel(), cp.options(), std::forward<Pfx>(pfx)...); }


	struct TransferContext {
		VmaAllocator  vma;
		VkCommandPool cmdPool;
		VkFence       cmdFence;
		VkQueue       cmdQueue;
		unsigned      cmdQueueFamily;
	};


	constexpr VkDevice vmaGetAllocatorDevice(VmaAllocator vma) noexcept { VmaAllocatorInfo r; vmaGetAllocatorInfo(vma, &r); return r.device; }


	constexpr bool operator==(const VkExtent2D& lh, const VkExtent2D& rh) noexcept {
		return (lh.width == rh.width) && (lh.height == rh.height);
	}

}
