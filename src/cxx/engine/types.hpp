#pragma once

#include <vector>
#include <type_traits>
#include <cstdint>
#include <stdfloat>

#include <glm/vec3.hpp>
#include <glm/vec4.hpp>
#include <glm/mat4x4.hpp>

#include <skengine_fwd.hpp>

#include <vk-util/desc_proxy.hpp>

#include <vma/vk_mem_alloc.h>

#include <sflog.hpp>



#define ALIGNF32(N_) alignas((N_) * sizeof(float))
#define ALIGNI32(N_) alignas((N_) * sizeof(uint32_t))
#define ALIGNFLAGS(N_) alignas((N_) * sizeof(uint32_t))



namespace SKENGINE_NAME_NS {

	// The signedness of an underlying type matters:
	// signed types allow special, predefined, valid (negative) values that
	// are not automatically generated by the `idgen` library.
	#define DECL_SCOPED_ENUM_(ENUM_, ALIAS_, UNDERLYING_) using ALIAS_ = UNDERLYING_; enum class ENUM_ : ALIAS_ { };
	DECL_SCOPED_ENUM_(ObjectId,        object_id_e,         uint_fast64_t)
	DECL_SCOPED_ENUM_(BoneId,          model_instance_id_e, uint_fast64_t)
	DECL_SCOPED_ENUM_(ModelInstanceId, bone_id_e,           uint32_t)
	DECL_SCOPED_ENUM_(MaterialId,      material_id_e,       uint32_t)
	DECL_SCOPED_ENUM_(ModelId,         model_id_e,          uint32_t)
	DECL_SCOPED_ENUM_(RendererId,      renderer_id_e,       unsigned)
	DECL_SCOPED_ENUM_(RenderTargetId,  render_target_id_e,  unsigned)
	DECL_SCOPED_ENUM_(RenderPassId,    render_pass_id_e,    unsigned)
	#undef DECL_SCOPED_ENUM_


	using Logger = sflog::Logger<std::shared_ptr<posixfio::OutputBuffer>>;


	struct TransferContext {
		VmaAllocator  vma;
		VkCommandPool cmdPool;
		VkFence       cmdFence;
		VkQueue       cmdQueue;
		unsigned      cmdQueueFamily;
	};


	struct Object {
		ModelId model_id;
		glm::vec3 position_xyz;
		glm::vec3 direction_ypr;
		glm::vec3 scale_xyz;
		bool      hidden;
	};


	struct Mesh {
		uint32_t index_count;
		uint32_t first_index;
	};


	struct Bone {
		Mesh mesh;
		std::string material;
		glm::vec3 position_xyz;
		glm::vec3 direction_ypr;
		glm::vec3 scale_xyz;
	};

	struct BoneInstance {
		ModelId    model_id;
		MaterialId material_id;
		ObjectId   object_id;
		glm::vec4 color_rgba;
		glm::vec3 position_xyz;
		glm::vec3 direction_ypr;
		glm::vec3 scale_xyz;
	};


	struct DrawBatch {
		ModelId    model_id;
		MaterialId material_id;
		uint32_t   vertex_offset;
		uint32_t   index_count;
		uint32_t   first_index;
		uint32_t   instance_count;
		uint32_t   first_instance;
	};


	struct RayLight {
		glm::vec3 direction;
		glm::vec3 color;
		float     intensity;
		float     aoa_threshold;
	};

	struct PointLight {
		glm::vec3 position;
		glm::vec3 color;
		float     intensity;
		float     falloff_exp;
	};


	/// This namespace defines structures as passed to
	/// the Vulkan device, which need to be carefully
	/// packed due to alignment shenanigans.
	///
	namespace dev {

		using dev_flags_e = uint32_t;

		enum FrameUniformFlagBits : dev_flags_e {
			FRAME_UNI_ZERO        = 0b0,
			FRAME_UNI_HDR_ENABLED = 0b1
		};

		enum class FrameUniformFlags : dev_flags_e { };


		struct Instance {
			ALIGNF32(1) glm::mat4 model_transf;
			ALIGNF32(1) glm::vec4 color_mul;
			ALIGNF32(1) std::float32_t rnd;
		};


		struct Light {
			ALIGNF32(4) glm::vec4 m0;
			ALIGNF32(4) glm::vec4 m1;
			ALIGNF32(1) std::float32_t m2;
			ALIGNF32(1) std::float32_t m3;
			ALIGNF32(1) std::float32_t m4;
			ALIGNF32(1) std::float32_t m5;
		};

		struct RayLight {
			ALIGNF32(4) glm::vec4 direction;
			ALIGNF32(4) glm::vec4 color;
			ALIGNF32(1) std::float32_t aoa_threshold;
			ALIGNF32(1) std::float32_t m4_unused;
			ALIGNF32(1) std::float32_t m5_unused;
			ALIGNF32(1) std::float32_t m6_unused;
		};
		static_assert(std::is_layout_compatible_v<Light, RayLight> && sizeof(Light) == sizeof(RayLight));

		struct PointLight {
			ALIGNF32(4) glm::vec4 position;
			ALIGNF32(4) glm::vec4 color;
			ALIGNF32(1) std::float32_t falloff_exp;
			ALIGNF32(1) std::float32_t m4_unused;
			ALIGNF32(1) std::float32_t m5_unused;
			ALIGNF32(1) std::float32_t m6_unused;
		};
		static_assert(std::is_layout_compatible_v<Light, PointLight> && sizeof(Light) == sizeof(PointLight));


		struct FrameUniform {
			ALIGNF32(1) glm::mat4 projview_transf;
			ALIGNF32(1) glm::mat4 proj_transf;
			ALIGNF32(1) glm::mat4 view_transf;
			ALIGNF32(1) glm::vec4 view_pos;
			ALIGNF32(1) glm::vec4 ambient_lighting;
			ALIGNI32(1) uint32_t  ray_light_count;
			ALIGNI32(1) uint32_t  point_light_count;
			ALIGNF32(1) uint32_t  shade_step_count;
			ALIGNF32(1) std::float32_t shade_step_smooth;
			ALIGNF32(1) std::float32_t shade_step_exp;
			ALIGNF32(1) std::float32_t dithering_steps;
			ALIGNF32(1) std::float32_t rnd;
			ALIGNF32(1) std::float32_t time_delta;
			ALIGNFLAGS(1) FrameUniformFlags flags;
		};


		struct MaterialUniform {
			ALIGNF32(1) float shininess;
		};

	}


	constexpr bool operator==(const VkExtent2D& lh, const VkExtent2D& rh) noexcept {
		return (lh.width == rh.width) && (lh.height == rh.height);
	}

}
